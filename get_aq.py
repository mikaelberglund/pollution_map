# -*- coding: utf-8 -*-
"""Get AQ.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bhu8E9VPcn29p_30TXq_DGJl18YA1s4f
"""

import requests as re
import pandas as pd
import ee
import numpy as np
import datetime
# from datetime import datetime as dt
import datetime as dt


#!earthengine authenticate

ee.Initialize()


if False:
    dftot = pd.read_pickle('dftot.pkl')
    dfs = pd.read_pickle('dfs.pkl')
    dfm = pd.read_pickle('dfm.pkl')


def LatLonImg(img,ar):
    img = img.addBands(ee.Image.pixelLonLat())

    img = img.reduceRegion(reducer=ee.Reducer.toList(),geometry=ar,maxPixels=1e13, scale=800, tileScale=8);

    data = np.array((ee.Array(img.get("result")).getInfo()))
    lats = np.array((ee.Array(img.get("latitude")).getInfo()))
    lons = np.array((ee.Array(img.get("longitude")).getInfo()))
    return lats, lons, data


def get_last(imagecol,s,e,ar,i):
    found_last = False
    day = 1
    d = dt.datetime.strptime(e, '%Y-%m-%d')
    while ~found_last:
        im_test = imagecol.filterDate(start = d - dt.timedelta(days=day),opt_end = d)
        # im_temp = im_test
        im_test = ee.Image(im_test.first()).unmask()
        if verbose:
            print(d - dt.timedelta(days=day))
        if (im_test.getInfo() is not None):
            ds = dt.datetime.strftime(d - dt.timedelta(days=day), '%Y-%m-%d')
            testds = dt.datetime.strptime(ds,'%Y-%m-%d')>=dt.datetime.strptime(s,'%Y-%m-%d')
            #
            # t = im_test.reduce(reducer=ee.Reducer.firstNonNull())
            # t = t.addBands(ee.Image.pixelLonLat()).getInfo()
            # t = ee.List([im_test.get('tropospheric_NO2_column_number_density')]).\
            #     reduce(reducer=ee.Reducer.firstNonNull()).getInfo()
            # t = t.reduceRegion(reducer=ee.Reducer.toList(), geometry=ar, maxPixels=1e13, scale=200,
            #                tileScale=8)  # TODO: Sätt maxPixels så att alla får samma storlek?
            if testds:
                date = dt.datetime.utcfromtimestamp(ee.Date(im_test.get('system:time_start')).getInfo()['value'] / 1000.)\
                    .strftime('%Y-%m-%d %H:%M')
                im_test = im_test.addBands(ee.Image.pixelLonLat())
                im_test = im_test.reduceRegion(reducer=ee.Reducer.toList(), geometry=ar, maxPixels=1e13, scale=100,tileScale=8) #TODO: Sätt maxPixels så att alla får samma storlek?
                # if verbose:
                #     if len(im_test.getInfo().get('tropospheric_NO2_column_number_density')) > 0:
                #         print('Max value in image is: '+str(np.array(im_test.getInfo().get('tropospheric_NO2_column_number_density')).max()))
                # if (len(im_test.getInfo().get('tropospheric_NO2_column_number_density'))/len(im_test.getInfo().get('latitude'))>0.8):
                if (np.array(im_test.getInfo().get('tropospheric_NO2_column_number_density')).mean() > 0):
                    # t = ee.List([im_temp.get('tropospheric_NO2_column_number_density')]). \
                    #     reduce(reducer=ee.Reducer.firstNonNull()).getInfo()
                    # t = t.addBands(ee.Image.pixelLonLat()).getInfo()
                    found_last = True
                    dftemp = pd.DataFrame(im_test.getInfo())
                    dftemp['date'] = date
                    dftemp['id'] = i
                    if verbose:
                        print('Found data on date: '+str(d - dt.timedelta(days=day)))
                        print('For location: ' + str(i) + '. Shape: ' + str(dftemp.shape))
                    return dftemp,date
                else:
                    day += 1
            elif (im_test.getInfo() is None) & testds:
                day += 1
            elif ~testds:
                return pd.DataFrame(columns=['latitude','longitude','date','location']),0

def get_data(locations,country):
    today=dt.datetime.strftime(dt.date.today(),'%Y-%m-%d')
    start = '2020-08-01'
    end = '2020-08-31'
    r = 0.01 #TODO: KÖR MED MINDRE RADIE OCH SKALA NER MINDRE, TEST OM DET GER MER RESULTAT OCH KAN KÖRAS SNABBARE PÅ NÅTT SÄTT?
    dfm = pd.DataFrame()
    dfs = pd.DataFrame()
    for i in locations.id:
        location = re.get('https://api.openaq.org/v1/locations/' + str(i))
        l = location.json()['results']['location']
        if verbose:
            print('Fetching location: '+str(i) + ' called: '+str(l))
        templat = location.json()['results']['coordinates']['latitude']
        templon = location.json()['results']['coordinates']['longitude']
        temparea = ee.Geometry.Rectangle(templon + 2 * r, templat + r, templon - 2 * r, templat - r)
        # myCollection = ee.ImageCollection("COPERNICUS/S5P/NRTI/L3_NO2").filterBounds(temparea) \
        #     .filterDate(start, end).select(['tropospheric_NO2_column_number_density']).filter(ee.Filter.eq('count', 1))
        landsat = ee.ImageCollection("COPERNICUS/S5P/NRTI/L3_NO2")
        landsat = landsat.filterBounds(temparea)
        landsat = landsat.filterDate(start, end)
        landsat = landsat.select(['tropospheric_NO2_column_number_density'])
        # if i == 'SE-42':
        im_test = ee.Image(landsat.first())
        t = im_test.reduce(reducer=ee.Reducer.firstNonNull())
        t = t.addBands(ee.Image.pixelLonLat()).getInfo()
        df,date = get_last(landsat,start, end, temparea,i)
        # print(landsat.size().getInfo())
        df['location'] = l
        dfs = dfs.append(df)
        # first_img = ee.Image(landsat.first())
        # try:
        #     lat, lon, data = LatLonImg(first_img, temparea)
        #     dftemp = pd.DataFrame(data)
        #     dftemp['lat'] = pd.DataFrame(lat)
        #     dftemp['lon'] = pd.DataFrame(lon)
        #     dftemp.columns = ['value', 'lat', 'lon']
        #     dfs = dfs.append(dftemp)
        if date!=0:
            # measurements = re.get('https://api.openaq.org/v1/measurements?coordinates=' + str(templat) + ',' + str(templon) +
            #                       '&date_from='+str(date-dt.timedelta(hours=1))+'&date_to='+str(date+dt.timedelta(days=1))+'&radius=10&parameter=no2&limit=1000')
            measurements = re.get(
                'https://api.openaq.org/v1/measurements?coordinates=' + str(templat) + ',' + str(templon) +'&date_from='+
                dt.datetime.strftime(dt.datetime.strptime(date, '%Y-%m-%d %H:%M') - dt.timedelta(hours=1), '%Y-%m-%d')+
                '&date_to='+dt.datetime.strftime(dt.datetime.strptime(date, '%Y-%m-%d %H:%M') + dt.timedelta(hours=1), '%Y-%m-%d')+
                '&radius=10&parameter=no2&limit=1000')
            measurements = pd.DataFrame(measurements.json()['results'])
            dfm = dfm.append(measurements)

    dfm.date = dfm.date.apply(pd.Series).utc
    dfm.date = pd.to_datetime(dfm.date)
    dfs.date = pd.to_datetime(dfs.date, format='%Y-%m-%d %H:%M', utc = True)
    dfs.date = dfs.date.dt.round(freq='H')
    # dftot = pd.merge(dfm,dfs,how='left',left_on=['location','date'],right_on=['location','date']) #TODO: Jag kanske måste göra en mer manuel merge för datum där jag väljer närmaste datum istället.
    dftott = pd.merge(dfm,dfs,how='left',left_on=['location'],right_on=['location'])
    dftot = pd.DataFrame()
    for i in locations.id:
        df = dftott[dftott.id == i]
        df = df[(df.date_x - df.date_y)== (df.date_x - df.date_y).min()].drop(['date_y','coordinates'],axis='columns')
        dftot = dftot.append(df)
    dftot = dftot.dropna(axis='rows').drop_duplicates()
    #dftot = dftot.drop('coordinates',axis='columns').drop_duplicates()
    locations[['longitude','latitude']] = locations.coordinates.apply(pd.Series)
    l = (locations.latitude-dfs[dfs.location == dfs.location.unique()[0]].latitude.mean()).idxmin()
    print(dfs)

    if True:
        dfs.to_pickle('dfs '+str( country )+' '+str( today )+'.pkl')
        dfm.to_pickle('dfm '+str( country )+' '+str( today )+'.pkl')
    l = []
    for i in dftot.id.unique():
        im = dftot[dftot.id == i][['latitude','longitude','tropospheric_NO2_column_number_density']].\
            drop_duplicates().pivot('latitude','longitude','tropospheric_NO2_column_number_density').values
        l.append(np.shape(im))
    pd.DataFrame(l).max()

    x_train = np.empty(shape=(1, pd.DataFrame(l).max()[0], pd.DataFrame(l).max()[1]))
    y_train = np.empty(shape=(1))
    for i in dftot.id.unique():
        im = dftot[dftot.id == i][['latitude', 'longitude', 'tropospheric_NO2_column_number_density']]\
            .drop_duplicates().pivot('latitude','longitude','tropospheric_NO2_column_number_density').values
        if np.shape(im)[1]<pd.DataFrame(l).max()[1]:
            im = np.pad(im, pad_width=((0,0),(0,1)), mode='edge')
        if np.shape(im)[0]<pd.DataFrame(l).max()[0]:
            im = np.pad(im, pad_width=((0,1),(0,0)), mode='edge')
        x_train = np.append(x_train, [im], axis=0)
        y_train = np.append(y_train,[dftot[dftot.id == i].value.unique()[0]],axis=0)
    if verbose:
        print('x_train has shape: ' +str(np.shape(x_train)))
        print('y_train has shape: ' +str(np.shape(y_train)))
    np.save('x_train '+str( country )+' '+str( today )+'.npy', x_train)
    np.save('y_train '+str( country )+' '+str( today )+'.npy', y_train)

    if verbose:
        print('Finished '+str( country )+str( today ))


# countries = re.get('https://api.openaq.org/v1/countries')
# countries = pd.DataFrame(countries.json()['results'])
# countries.code.unique()
# countries = ['SE','NO','DK','DE','NL','UK']
countries = ['DK','DE','NL','UK']
verbose = True
# EXECUTE PER COUNTRY
for c in countries:
    locations = re.get('https://api.openaq.org/v1/locations?country[]='+str(c))
    locations = pd.DataFrame(locations.json()['results'])
    get_data(locations,c)

